.define nCMD_GPIO 27        ; nCommand GPIO input
.define nSTRB_GPIO 28       ; nStrobe GPIO input
.define nRW_GPIO 9          ; nRead/write GPIO input

; Program to manage command
.program pico_profile_cmd
.side_set 1

.wrap_target
next_cmd:
    wait 0 gpio nCMD_GPIO   side 1      ; Wait for the CMD to be low
    set pins, 0x1           side 0      ; Put 1 to the bus
    wait 1 gpio nCMD_GPIO   side 0      ; Wait for the CMD to be high
    in pins, 8              side 0      ; Read response
    pull                    side 0      ; Wait for MCU to answer
    mov x, osr              side 0      ; 
    jmp !x next_cmd         side 0      ; MCU rejected command
    set x, 6                side 1      ; Raise BSY
get_cmd_bytes:
    wait 0 gpio nSTRB_GPIO  side 1      ; Wait for cmd to be strobed
    in pins, 8              side 1      ; Get command bytes
    jmp x-- get_cmd_bytes   side 1      ; Until we read 6 bytes
    wait 0 gpio nCMD_GPIO   side 1      ; Wait for the CMD to be low
    pull                    side 1      ; Get data from MCU (command answer)
    out pins, 8             side 0      ; Set answer to bus and lower BSY
    wait 1 gpio nCMD_GPIO   side 0      ; Wait for the CMD to be high
    in pins, 8              side 0      ; Read response (should be 0x55)
    pull                    side 0      ; Wait for MCU to be ready
    mov x, osr              side 1      ; Raise BSY (ready for data)
    jmp !x next_cmd         side 1      ; MCU done command (if 0)
    wait 1 gpio nCMD_GPIO   side 1      ; Wait for the CMD to be low
    pull                    side 1      ; Get MCU command response
    out pins, 8             side 0      ; Set answer to bus and lower BSY
    wait 1 gpio nCMD_GPIO   side 0      ; Wait for the CMD to be high
    in pins, 8              side 0      ; Read response (should be 0x55)
    pull                    side 0      ; Wait for MCU to be ready
.wrap

; Program to read data
.program pico_profile_data

.wrap_target
wait_data:
    wait 0 gpio nSTRB_GPIO              ; Waits for strobe to be low
    wait 1 gpio nSTRB_GPIO              ; Waits for strobe to be high
    jmp pin write_data                  ; Jumps depending on R/W
read_data:
    ; Apple read something on bus
    out pins, 8                         ; Sets output to what it's in OSR
    jmp wait_data
write_data:
    in pins, 11                         ; Put on bus what is in ISR
.wrap


% c-sdk {

static inline void pico_profile_cmd_pio_init(PIO pio, uint sm, uint offset, uint out_base_pin) {
    pio_sm_set_consecutive_pindirs(pio, sm, out_base_pin, 8, true);
    for (uint i = out_base_pin; i < out_base_pin + 8; ++i)
        pio_gpio_init(pio, i);
    pio_sm_config c = pico_profile_cmd_program_get_default_config(offset);
    sm_config_set_out_pins(&c, out_base_pin, 8);
    sm_config_set_out_shift(&c, true, true, 8);
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void pico_profile_data_pio_init(PIO pio, uint sm, uint offset) {
    //Configure outputs direction
    //0xFF : GPIO0 to GPIO8 as output (others as input)
    //0x147F00FF : Modify GPIO 0-7, 16-22, 26, 28
    pio_sm_set_pindirs_with_mask(pio, sm, 0xFF, 0x147F00FF);
    for(uint i=0; i<=8; ++i)
        pio_gpio_init(pio, i);
    for(uint i=16; i<=22; ++i)
        pio_gpio_init(pio, i);    
    pio_gpio_init(pio, 26);
    pio_gpio_init(pio, 28);    
    pio_sm_config c = pico_profile_data_program_get_default_config(offset);
    sm_config_set_out_pins(&c, 0, 8);               //8 outputs
    sm_config_set_out_shift(&c, true, true, 8);     //Shift right, autopull of 8 bits
    sm_config_set_in_pins(&c, 16);                  //Input starting at GPIO16
    sm_config_set_in_shift(&c, false, true, 11);    //Shift right, autopull of 11 bits (to take into account GPIO 26)
    sm_config_set_jmp_pin(&c, 9);                   //Use R/W as jump pin

    pio_sm_init(pio, sm, offset, &c);           //Initialize state machine
    pio_sm_set_enabled(pio, sm, true);          //Enable state machine
}

%}